# Тестовое задание для Фьюче

React ts приложение-поиск для Google Books API.
- Стейт менеджер: MobX
- Сторонние библиотеки: Lodash для map и foreach с обьектами, Axios для отправки запросов
- Линтеры: esLint, editorConfigChecker
- Сборщик: vite
- Тестирование ts/tsx: Jest, react development tools
- Тестирование запросов: Postman

## Ссылка на сайт

```

```

## Скрипты

```
npm i
```
Запускает приложение в дев режиме

```
npm run test
```
Запускает тесты

```
npm run build
```
Собирает приложение в папку dist

```
npm run preview
```
запускает собранное приложение


## Cсылка на фигма

Ссылка на макет figma
```
https://www.figma.com/file/4PUYtyUft7lWzkS91Vk11f/Untitled?type=design&node-id=0%3A1&mode=design&t=f1r2EHlZt43mCtLH-1
```

## API KEY
```
AIzaSyDUXIw7OS6KiOjd8g4YC8WNvprnou-b8kI
```

## Проблемы

>  Поиск по жанрам не всегда точный(иногда апи возвращает не ту категорию), чтобы решить это можно создать воркера который будет сам сортировать полученный результат, однако придется делать свою пагинацию, в рамках тестового решил оставить так как есть.

> Запрос с startIndex=1 и startIndex=10 (итд) возвращают разное количество результатов, причем логично было бы, если меньше на количество предыдущих страниц, но при разных запросах рандомно ¯\_(ツ)_/¯

## Неплохо бы

- [ ] Проставить altы

## Текст задания

## Задание

Необходимо разработать React-приложение поиска книг с помощью Google Books API. Документация: https://developers.google.com/books/docs/v1/using. Для авторизации запросов к API выбрать способ с предоставлением API key (https://developers.google.com/books/docs/v1/using#APIKey).

Дополнительным плюсом будет: Финальный билд приложения должен быть запускаться из __Docker контейнера__ (хотябы с минимальной конфигурацией)

__Функционал__

- Должны быть текстовое поле и кнопка поиска. По введенной пользователем подстроке производится поиск книг. Триггером к поиску является либо нажатие Enter (когда текстовое поле в фокусе), либо нажатие кнопки поиска.
- Фильтрация по категориям. Ниже текстового поля располагается селект с категориями: all, art, biography, computers, history, medical, poetry. Если выбрано "all" (выбрано изначально), то поиск производится по всем категориям.
- Сортировка. Рядом с селектом категорий находится селект с вариантами сортировки: relevance (выбран изначально), newest.
- Найденные книги отображаются карточками, каждая из которых состоит из изображения обложки книги, названия книги, названия категории и имен авторов. Если для книги приходит несколько категорий, то отображается только первая. Авторы отображаются все. Если не приходит какой-либо части данных, то вместо нее просто пустое место.
- Над блоком с карточками отображается количество найденных по запросу книг.
- Пагинация реализована по принципу 'load more'. Ниже блока с карточками находится кнопка 'Load more', по клику на нее к уже загруженным книгам подгружаются еще. Шаг пагинации - 30.
- При клике на карточку происходит переход на детальную страницу книги, на которой выводятся ее данные: изображение обложки, название, все категории, все авторы, описание.

__Замечания__

- __Обязательно__ использование Redux/MobX.
- __Желательно__ Typescript
- Во время загрузки книг стоит показать какой-то индикатор
- Использование сторонних библиотек будет плюсом только в случае если это оправданно и вы сможете объяснить причину выбора. Показав свои знания в грамотном применении сторонних готовых решений, вы имеете шанс повысить свою профессиональную привлекательность для нас.
- Пишите код так, как бы вы его писали в работе &mdash; внутренности задания будут оцениваться даже тщательней, чем внешнее соответствие заданию. Код должен быть организован так, чтобы его можно было заново использовать.
- Помните про обработку ошибок!
- Верстка может быть самая простая, однако она не должна ломаться при разрешениях от 320px до 1920px. Визуализацию и украшение делайте на ваш вкус. Мы не против использования [Bootstrap](http://getbootstrap.com/) или похожего UI фреймворк, но только для UI представления (нельзя использовать JS код для решения задачи, но можно использовать для оформительских эффектов (анимации и тому подобное))!

